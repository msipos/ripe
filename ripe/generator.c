// Copyright (C) 2008  Maksim Sipos <msipos@mailc.net>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#include "ripe/ripe.h"
#include "clib/stringbuf.h"
#include "clib/dict.h"
#include <setjmp.h>

///////////////////////////////////////////////////////////////////////////////
// UTILITY
///////////////////////////////////////////////////////////////////////////////
static const char* util_trim_ends(const char* input)
{
  char* txt = mem_strdup(input);
  txt++;
  txt[strlen(txt)-1] = 0;
  return txt;
}

// In str, replace each character c by string replace
static const char* util_replace(const char* str, const char c,
                                const char* replace)
{
  // Ultra inneficient, but who cares.
  StringBuf sb;
  sbuf_init(&sb, "");
  while(*str != 0){
    if (*str == c){
      sbuf_printf(&sb, "%s", replace);
    } else {
      sbuf_printf(&sb, "%c", *str);
    }
    str++;
  }
  const char* out = mem_strdup(sb.str);
  sbuf_deinit(&sb);
  return out;
}

static const char* util_make_c_name(const char* ripe_name)
{
  char* c_name = mem_asprintf("__%s", ripe_name);
  char* s = c_name;
  while (*s != 0){
    if (*s == '?' or *s == '!' or *s == '.'){
      *s = '_';
    }
    s++;
  }
  return c_name;
}

///////////////////////////////////////////////////////////////////////////////
// ERROR HANDLING
///////////////////////////////////////////////////////////////////////////////

static jmp_buf jb;
static const char* source_filename;
static int error_line_max;
static int error_line_min;

// Try to populate error_filename and error_line_* with information from this
// node.
static void error_traverse(Node* node)
{
  if (node->line != -1) {
    if (error_line_max == -1) {
      error_line_max = node->line;
      error_line_min = node->line;
    } else {
      if (error_line_max < node->line) error_line_max = node->line;
      if (error_line_min > node->line) error_line_min = node->line;
    }
  }
  for (int i = 0; i < node_num_children(node); i++){
    error_traverse(node_get_child(node, i));
  }
}

// If node != NULL, attempt to query information about the location of the
// error.
static void raise_error(const char* error, Node* node)
{
  error_line_min = -1;
  error_line_max = -1;
  if (node != NULL) error_traverse(node);
  const char* error_numbers = NULL;
  if (error_line_min != -1){
    if (error_line_min == error_line_max){
      error_numbers = mem_asprintf("%d", error_line_min);
    } else {
      error_numbers = mem_asprintf("%d-%d", error_line_min, error_line_max);
    }
  }

  if (error_numbers != NULL){
    fprintf(stderr, "%s:%s: %s\n", source_filename, error_numbers, error);
  } else {
    fprintf(stderr, "%s: %s\n", source_filename, error);
  }
  longjmp(jb, 1);
}

///////////////////////////////////////////////////////////////////////////////
// OUTPUT DUMPING
///////////////////////////////////////////////////////////////////////////////

static StringBuf sb_contents;
static StringBuf sb_header;
static StringBuf sb_init1;
static StringBuf sb_init2;

static void dump_init()
{
  sbuf_init(&sb_contents, "");
  sbuf_init(&sb_header, "");
  sbuf_init(&sb_init1, "");
  sbuf_init(&sb_init2, "");
}

static void dump_output(FILE* f, const char* module_name)
{
  fprintf(f, "// %s.c -- Autogenerated by Ripec\n", module_name);
  fprintf(f, "#include \"modules/modules.h\"\n");
  fprintf(f, "%s", sb_header.str);
  fprintf(f, "%s", sb_contents.str);

  fprintf(f, "void init1_%s(){\n", module_name);
  fprintf(f, "%s", sb_init1.str);
  fprintf(f, "}\n");

  fprintf(f, "void init2_%s(){\n", module_name);
  fprintf(f, "%s", sb_init2.str);
  fprintf(f, "}\n");
}

///////////////////////////////////////////////////////////////////////////////
// DYNAMIC AND STATIC SYMBOL TABLES
///////////////////////////////////////////////////////////////////////////////

static Dict static_symbols; // symbol_name -> integer 0...
static Dict dynamic_symbols; // symbol name -> integer 0...

static void tables_init()
{
  dict_init(&static_symbols, sizeof(char*), sizeof(uint64),
            dict_hash_string, dict_equal_string);
  dict_init(&dynamic_symbols, sizeof(char*), sizeof(uint64),
            dict_hash_string, dict_equal_string);
}

static uint64 static_symbol2(const char* name)
{
  static uint64 counter = 0;

  uint64 value;
  // Already is in the symbol table
  if (dict_query(&static_symbols, &name, &value)){
    return value;
  }

  // Add it to the symbol table
  dict_set(&static_symbols, &name, &counter);
  sbuf_printf(&sb_header, "static Value ssym%"PRIu64";\n", counter);
  sbuf_printf(&sb_init2, "  ssym%"PRIu64" = ssym_get(\"%s\");\n",
                         counter, name);
  counter++;
  return counter-1;
}
static const char* static_symbol(const char* name)
{
  return mem_asprintf("ssym%"PRIu64, static_symbol2(name));
}

// Register a dynamic symbol and return a string that can be used
// C code to identify this symbol.
static uint64 dynamic_symbol2(const char* name)
{
  static uint64 counter = 0;

  uint64 value;
  if (dict_query(&dynamic_symbols, &name, &value)){
    return value;
  }

  // Add it to the symbol table
  const char* dsym = mem_asprintf("dsym%"PRIu64, counter);
  dict_set(&dynamic_symbols, &name, &counter);
  sbuf_printf(&sb_header, "static Value %s;\n", dsym);
  sbuf_printf(&sb_init1, "  %s = dsym_get(\"%s\");\n",
                         dsym, name);
  counter++;
  return counter-1;
}
static const char* dynamic_symbol(const char* name)
{
  return mem_asprintf("dsym%"PRIu64, dynamic_symbol2(name));
}

///////////////////////////////////////////////////////////////////////////////
// MODULE STACK
///////////////////////////////////////////////////////////////////////////////
static Array module_stack;
static const char* module_prefix;

static void module_init()
{
  array_init(&module_stack, const char*);
  module_prefix = "";
}

static void module_gen_prefix()
{
  if (module_stack.size > 0){
    module_prefix = array_get(&module_stack, char*, 0);
    for (int i = 1; i < module_stack.size; i++){
      module_prefix = mem_asprintf("%s.%s", module_prefix,
                                   array_get(&module_stack, char*, i));
    }
    module_prefix = mem_asprintf("%s.", module_prefix);
  } else {
    module_prefix = "";
  }
}

static void module_push(const char* name)
{
  array_append(&module_stack, mem_strdup(name));
  module_gen_prefix();
}

static void module_pop()
{
  assert(module_stack.size > 0);
  array_pop(&module_stack, const char*);
  module_gen_prefix();
}

///////////////////////////////////////////////////////////////////////////////
// CURRENT CONTEXT
///////////////////////////////////////////////////////////////////////////////

typedef enum {
  CLASS_VIRTUAL_OBJECT,
  CLASS_CDATA_OBJECT,
  CLASS_FIELD_OBJECT
} ClassType;

int context;
#define CONTEXT_NONE 1
#define CONTEXT_CLASS 2
const char* context_class_name;
const char* context_class_c_name;
const char* context_class_typedef;
ClassType context_class_type;
Dict* context_class_dict;
int context2;
#define CONTEXT_FUNC        1
#define CONTEXT_CONSTRUCTOR 2
#define CONTEXT_METHOD      3
const char* context2_method_value_name;

///////////////////////////////////////////////////////////////////////////////
// LOCAL VARIABLE STACK
///////////////////////////////////////////////////////////////////////////////

static Array locals_arr; // For each function.

static void locals_init()
{
  array_init(&locals_arr, Dict*);
}

static void push_locals()
{
  Dict* locals = dict_new(sizeof(char*), sizeof(char*),
                          dict_hash_string, dict_equal_string);
  array_append(&locals_arr, locals);
}

static void pop_locals()
{
  array_pop(&locals_arr, Dict*);
}

static void set_local(const char* ripe_name, const char* c_name)
{
  Dict* dict = array_get(&locals_arr, Dict*, locals_arr.size - 1);
  dict_set(dict, &ripe_name, &c_name);
}

static const char* register_local(const char* ripe_name)
{
  const char* c_name = util_make_c_name(ripe_name);
  set_local(ripe_name, c_name);
  return c_name;
}

// Test if ripe_name is a currently defined variable. Otherwise it should be
// treated like a static symbol.
static const char* query_local(const char* ripe_name)
{
  for (int i = locals_arr.size - 1; i >= 0; i--){
    Dict* dict = array_get(&locals_arr, Dict*, i);
    const char* value;
    if (dict_query(dict, &ripe_name, &value)){
      return value;
    }
  }
  return NULL;
}

///////////////////////////////////////////////////////////////////////////////
// EVALUATING AST
///////////////////////////////////////////////////////////////////////////////
static uint dowhile_semaphore;

static const char* eval_expr(Node* expr);

static const char* eval_comma_expr_list(Node* expr_list)
{
  assert(expr_list->type == EXPR_LIST);
  StringBuf sb_temp;
  sbuf_init(&sb_temp, "");
  for (int i = 0; i < expr_list->children.size; i++){
    sbuf_printf(&sb_temp, ", %s", eval_expr(node_get_child(expr_list, i)));
  }
  const char* result = mem_strdup(sb_temp.str);
  sbuf_deinit(&sb_temp);
  return result;
}

static const char* obj_call(const char* obj, const char* method, int num_args,
                            const char* comma_args)
{
  return mem_asprintf("method_call%d(%s, %s %s)",
                      num_args, obj, dynamic_symbol(method), comma_args);
}

// Returns code for accessing index (if assign = NULL), or setting index
// when assign is of type expr.
static const char* eval_index(Node* self, Node* idx, Node* assign)
{
  if (assign == NULL) {
    return obj_call(eval_expr(self), "index", idx->children.size,
                    eval_comma_expr_list(idx));
  } else {
    return obj_call(eval_expr(self), "index_set", idx->children.size+1,
                    mem_asprintf("%s, %s",
                                 eval_comma_expr_list(idx),
                                 eval_expr(assign)));
  }
}

// Attempt to evaluate the EXPR_FIELD as a static field. If it succeeds, then
// return a string of the static symbol (unregistered). Otherwise return NULL.
static const char* eval_expr_as_static(Node* expr)
{
  switch(expr->type){
    case ID:
      // If ID is a variable, then it can't be a static symbol.
      if (query_local(expr->text) == NULL) return expr->text;
      else return NULL;
    case EXPR_FIELD:
      {
        Node* parent = node_get_child(expr, 0);
        Node* field = node_get_child(expr, 1);
        assert(field->type == ID);
        const char* s = eval_expr_as_static(parent);
        if (s != NULL) return mem_asprintf("%s.%s", s, field->text);
        else return NULL;
      }
    default:
      // Anything other than ID or EXPR_FIELD means that it cannot be a
      // static symbol.
      return NULL;
  }
}

static const char* eval_expr(Node* expr)
{
  if (is_unary_op(expr))
    return mem_asprintf("%s(%s)",
                        unary_op_map(expr->type),
                        eval_expr(node_get_child(expr, 0)));
  if (is_binary_op(expr))
    return mem_asprintf("%s(%s, %s)",
                        binary_op_map(expr->type),
                        eval_expr(node_get_child(expr, 0)),
                        eval_expr(node_get_child(expr, 1)));

  switch(expr->type){
    case K_TRUE:
      return mem_strdup("VALUE_TRUE");
    case K_FALSE:
      return mem_strdup("VALUE_FALSE");
    case K_NIL:
      return mem_strdup("VALUE_NIL");
    case K_EOF:
      return mem_strdup("VALUE_EOF");
    case ID:
      {
        const char* local = query_local(expr->text);
        if (local == NULL) return static_symbol(expr->text);
        return mem_strdup(local);
      }
    case INT:
      return mem_asprintf("int64_to_val(%s)", expr->text);
    case DOUBLE:
      return mem_asprintf("double_to_val(%s)", expr->text);
    case STRING:
      {
        const char* str = expr->text;
        return mem_asprintf("string_to_val(%s)", str);
      }
      break;
    case CHARACTER:
      {
        const char* str = expr->text;
        return mem_asprintf("int64_to_val(%d)", (int) str[1]);
      }
      break;
    case EXPR_ARRAY:
      {
        Node* expr_list = node_get_child(expr, 0);
        return mem_asprintf("array1_to_val2(%u %s)",
                            expr_list->children.size,
                            eval_comma_expr_list(expr_list));
      }
    case EXPR_INDEX:
      return eval_index(node_get_child(expr, 0), node_get_child(expr, 1), NULL);
    case EXPR_FIELD_CALL:
      {
        Node* parent = node_get_child(expr, 0);
        Node* field = node_get_child(expr, 1);
        Node* arg_list = node_get_child(expr, 2);
        assert(field->type == ID);

        // Attempt to evaluate parent as a static symbol.
        const char* s = eval_expr_as_static(parent);
        if (s != NULL){
          // Static call
          return mem_asprintf(
                   "func_call%u(%s %s)",
                   node_num_children(arg_list),
                   static_symbol(mem_asprintf("%s.%s", s, field->text)),
                   eval_comma_expr_list(arg_list)
                 );
        } else {
          // Dynamic call
          return obj_call(
                   eval_expr(parent),
                   field->text,
                   node_num_children(arg_list),
                   eval_comma_expr_list(arg_list)
                 );
        }
      }
    case EXPR_ID_CALL:
      {
        Node* left = node_get_child(expr, 0);
        Node* arg_list = node_get_child(expr, 1);
        assert(left->type == ID);
        if (query_local(left->text))
          raise_error(mem_asprintf("variable '%s' called as a function",
                                   left->text), expr);
        if (strcmp(left->text, "tuple") == 0){
          return mem_asprintf(
                   "tuple_to_val(%u %s)",
                   node_num_children(arg_list),
                   eval_comma_expr_list(arg_list)
                 );
        }
        return mem_asprintf(
                 "func_call%u(%s %s)",
                 node_num_children(arg_list),
                 static_symbol(left->text),
                 eval_comma_expr_list(arg_list)
               );
      }
      break;
    case EXPR_RANGE_BOUNDED:
      {
        Node* left = node_get_child(expr, 0);
        Node* right = node_get_child(expr, 1);
        return mem_asprintf("range_to_val(RANGE_BOUNDED, "
                            "val_to_int64(%s), val_to_int64(%s))",
                            eval_expr(left),
                            eval_expr(right));
      }
    case EXPR_RANGE_BOUNDED_LEFT:
      return mem_asprintf("range_to_val(RANGE_BOUNDED_LEFT, "
                          "val_to_int64(%s), 0)",
                          eval_expr(node_get_child(expr, 0)));
    case EXPR_RANGE_BOUNDED_RIGHT:
      return mem_asprintf("range_to_val(RANGE_BOUNDED_RIGHT, "
                          "0, val_to_int64(%s))",
                          eval_expr(node_get_child(expr, 0)));
    case EXPR_RANGE_UNBOUNDED:
      return mem_strdup("range_to_val(RANGE_UNBOUNDED, 0, 0)");

    case EXPR_FIELD:
      {
        // Attempt to evaluate this field as a static symbol.
        const char* s = eval_expr_as_static(expr);
        if (s == NULL){
          // Dynamic field.
          Node* parent = node_get_child(expr, 0);
          Node* field = node_get_child(expr, 1);

          return mem_asprintf("field_get(%s, %s)",
                              eval_expr(parent),
                              dynamic_symbol(field->text));
        } else {
          // Could be a global variable.
          const char* global_var = query_local(s);
          if (global_var != NULL){
            return global_var;
          }

          return static_symbol(s);
        }
      }
      break;
    case EXPR_AT_VAR:
      {
        const char* name = node_get_string(expr, "name");
        if (context != CONTEXT_CLASS){
          raise_error(mem_asprintf("'@%s' in something that's not a class", name),
                      expr);
        }
        if (context_class_type != CLASS_FIELD_OBJECT){
          raise_error(mem_asprintf("'@%s' in a class that's not a field class",
                                   name), expr);
        }
        char* field_int_var;
        if (not dict_query(context_class_dict, &name, &field_int_var)){
          static int counter = 0; counter++;
          field_int_var = mem_asprintf("field_int_%d", counter);
          sbuf_printf(&sb_header, "static int %s;\n", field_int_var);
          sbuf_printf(&sb_init2, "  %s = klass_get_field_int("
                      "%s, dsym_get(\"%s\"));\n", field_int_var,
                      context_class_c_name, name);
        }
        return mem_asprintf("_c_data[%s]", field_int_var);
      }
    case C_CODE:
      {
        const char* str = util_trim_ends(expr->text);
        if (context2 == CONTEXT_METHOD or context2 == CONTEXT_CONSTRUCTOR){
          if (strchr(str, '@') != NULL and context_class_type != CLASS_CDATA_OBJECT)
            raise_error("@ in C code in a class that is not cdata", expr);
          return util_replace(str, '@', "_c_data->");
        }
        return str;
      }
    default:
      assert_never();
  }
  return NULL;
}

static void compile_stmt_expr(Node* stmt)
{
  Node* expr = node_get_child(stmt, 0);
  if (expr->type == EXPR_ID_CALL or expr->type == EXPR_FIELD_CALL){
    sbuf_printf(&sb_contents, "  %s;\n", eval_expr(expr));
  } else if (expr->type == C_CODE) {
    sbuf_printf(&sb_contents, "  %s\n", eval_expr(expr));
  } else {
    raise_error("invalid expression in an expression statement", stmt);
  }
}

static void compile_stmtlist(Node* stmtlist);
static void compile_stmtlist_no_locals(Node* stmtlist);

static void compile_stmt(Node* stmt)
{
  switch(stmt->type){
    case STMT_EXPR:
      compile_stmt_expr(stmt);
      break;
    case STMT_RETURN:
      if (context2 == CONTEXT_CONSTRUCTOR){
        raise_error("return not allowed in a constructor", stmt);
      }
      sbuf_printf(&sb_contents, "  return %s;\n",
                                eval_expr(node_get_child(stmt, 0)));

      break;
    case STMT_LOOP:
      {
        sbuf_printf(&sb_contents, "  for(;;){\n");
        dowhile_semaphore++;
        compile_stmtlist(node_get_child(stmt, 0));
        dowhile_semaphore--;
        sbuf_printf(&sb_contents, "  }\n");
      }
      break;
    case STMT_IF:
      {
        sbuf_printf(&sb_contents, "  if (%s == VALUE_TRUE) {\n",
                                  eval_expr(node_get_child(stmt, 0)));
        compile_stmtlist(node_get_child(stmt, 1));
        sbuf_printf(&sb_contents, "  }\n");
      }
      break;
    case STMT_ELIF:
      {
        sbuf_printf(&sb_contents, "  else if (%s == VALUE_TRUE) {\n",
                                  eval_expr(node_get_child(stmt, 0)));
        compile_stmtlist(node_get_child(stmt, 1));
        sbuf_printf(&sb_contents, "  }\n");
      }
      break;
    case STMT_ELSE:
      {
        sbuf_printf(&sb_contents, "  else {\n");
        compile_stmtlist(node_get_child(stmt, 0));
        sbuf_printf(&sb_contents, "  }\n");
      }
      break;
    case STMT_TRY:
      {
        sbuf_printf(&sb_contents, "  if (exc_register_any() == 0){\n");
        compile_stmtlist(node_get_child(stmt, 0));
        sbuf_printf(&sb_contents, "  } else {\n");
        compile_stmtlist(node_get_child(stmt, 1));
        sbuf_printf(&sb_contents, "  }\n");
      }
      break;
    case STMT_WHILE:
      {
        sbuf_printf(&sb_contents, "  while (%s == VALUE_TRUE) {\n",
                                  eval_expr(node_get_child(stmt, 0)));
        dowhile_semaphore++;
        compile_stmtlist(node_get_child(stmt, 1));
        dowhile_semaphore--;
        sbuf_printf(&sb_contents, "  }\n");
      }
      break;
    case STMT_BREAK:
      if (dowhile_semaphore == 0){
        raise_error("break outside a loop", stmt);
      }
      sbuf_printf(&sb_contents, "  break;\n");
      break;
    case STMT_CONTINUE:
      if (dowhile_semaphore == 0){
        raise_error("continue outside a loop", stmt);
      }
      sbuf_printf(&sb_contents, "  continue;\n");
      break;
    case STMT_ASSIGN:
      {
        Node* left = node_get_child(stmt, 0);
        Node* right = node_get_child(stmt, 1);
        switch (left->type){
          case ID:
            {
              const char* c_name = query_local(left->text);
              if (c_name == NULL){
                // Register the variable
                sbuf_printf(&sb_contents, "  Value %s = %s;\n",
                            register_local(left->text), eval_expr(right));
              } else {
                sbuf_printf(&sb_contents, "  %s = %s;\n", c_name, eval_expr(right));
              }
            }
            break;
          case EXPR_INDEX:
            sbuf_printf(&sb_contents, "  %s;\n",
                        eval_index(node_get_child(left, 0),
                                   node_get_child(left, 1),
                                   right));
            break;
          case EXPR_FIELD:
            sbuf_printf(&sb_contents, "  field_set(%s, %s, %s);\n",
                        eval_expr(node_get_child(left, 0)),
                        dynamic_symbol(node_get_child(left, 1)->text),
                        eval_expr(right));
            break;
          case EXPR_AT_VAR:
            sbuf_printf(&sb_contents, "  %s = %s;\n",
                        eval_expr(left),
                        eval_expr(right));
            break;
          default:
            raise_error("invalid lvalue of assignment statement", stmt);
        }
      }
      break;
    case STMT_FOR:
      {
        static int iterator_counter = 0;
        iterator_counter++;

        const char* c_iterator = mem_asprintf("__iterator%d", iterator_counter);
        const char* c_object = eval_expr(node_get_child(stmt, 1));

        // First get the iterator.
        sbuf_printf(&sb_contents, "  Value %s = %s;\n",
                    c_iterator, obj_call(c_object, "get_iter", 0, ""));

        // Now make a local variable
        const char* r_variable = node_get_child(stmt, 0)->text;
        if (query_local(r_variable)){
          raise_error(mem_asprintf("variable '%s' already defined", r_variable),
                      stmt);
        }

        push_locals();
        const char* c_variable = register_local(r_variable);
        const char* c_iterator_call = obj_call(c_iterator, "iter", 0, "");
        sbuf_printf(&sb_contents, "  for(Value %s = %s;"
                                    "%s != VALUE_EOF;"
                                    "%s = %s)"
                                    "{\n",
                    c_variable, c_iterator_call,
                    c_variable,
                    c_variable, c_iterator_call
                    );
        dowhile_semaphore++;
        compile_stmtlist_no_locals(node_get_child(stmt, 2));
        dowhile_semaphore--;
        sbuf_printf(&sb_contents, "  }\n");
        pop_locals();
      }
      break;
    case STMT_PASS:
      break;
    default:
      assert_never();
  }
}

static void compile_stmtlist(Node* stmtlist)
{
  push_locals();
  compile_stmtlist_no_locals(stmtlist);
  pop_locals();
}

static void compile_stmtlist_no_locals(Node* stmtlist)
{
  int prev_stmt_type = 0;
  for (uint i = 0; i < stmtlist->children.size; i++){
    Node* stmt = node_get_child(stmtlist, i);
    if (stmt->type == STMT_ELSE or stmt->type == STMT_ELIF){
      if (prev_stmt_type != STMT_IF and
          prev_stmt_type != STMT_ELIF){
        raise_error("statement must follow if or elif", stmt);
      }
    }
    prev_stmt_type = stmt->type;
    compile_stmt(node_get_child(stmtlist, i));
  }
}

// Ensures that param_list is valid and returns if the function is vararg.
static bool check_vararg(Node* param_list)
{
  uint num_params = param_list->children.size;
  for (uint i = 0; i < num_params; i++){
    Node* param = node_get_child(param_list, i);
    if (param->type == ARRAY_ARG){
      if (i != num_params - 1){
        raise_error("array_argument must be last", param_list);
      }
      return true;
    }
  }
  return false;
}

// Constructs the text of the form
//   Value __param1, Value __param2, Value __param3
// and registers locals while doing that.
static const char* gen_params(Node* param_list)
{
  StringBuf sb;
  sbuf_init(&sb, "");
  for (uint i = 0; i < param_list->children.size; i++){
    Node* param = node_get_child(param_list, i);

    const char* var_name;
    if (param->type == ARRAY_ARG){
      // This is because ARRAY_ARG has the form
      //     ARRAY_ARG -> ID (text = var_name)
      // whereas regular argument has simply
      //     ID (text = var_name).
      var_name = node_get_child(param, 0)->text;
    } else {
      var_name = param->text;
    }
    const char* c_var_name = register_local(var_name);
    if (i == 0){
      sbuf_printf(&sb, "Value %s", c_var_name);
    } else {
      sbuf_printf(&sb, ", Value %s", c_var_name);
    }
  }
  const char* s = mem_strdup(sb.str);
  sbuf_deinit(&sb);
  return s;
}

// Generate all the statements, and optional return VALUE_NIL at the end.
static void gen_func_code(Node* stmt_list)
{
  dowhile_semaphore = 0;
  compile_stmtlist(stmt_list);
  // If last statement is of type STMT_RETURN, no need for another return.
  if (stmt_list->children.size == 0
        or
      node_get_child(stmt_list, stmt_list->children.size-1)->type != STMT_RETURN)
    sbuf_printf(&sb_contents, "  return VALUE_NIL;\n");
}

static void compile_function(Node* function)
{
  // Deal with counter
  static uint counter = 0;
  counter++;
  const char* name = mem_asprintf("%s%s", module_prefix,
                                  node_get_string(function, "name"));
  Node* param_list = node_get_child(function, 0);
  Node* stmt_list = node_get_child(function, 1);
  uint num_params = param_list->children.size;
  context2 = CONTEXT_FUNC;

  // Generate
  push_locals();
  const char* c_name = mem_asprintf("__func%u_%s",
                                    counter,
                                    util_make_c_name(name));
  sbuf_printf(&sb_contents, "static Value %s(%s){\n",
              c_name, gen_params(param_list));
  sbuf_printf(&sb_init1, "  Value v_%s = func%u_to_val(%s);\n",
              c_name, num_params, c_name);
  if (check_vararg(param_list))
    sbuf_printf(&sb_init1, "  func_set_vararg(v_%s);\n", c_name);
  sbuf_printf(&sb_init1, "  ssym_set(\"%s\", v_%s);\n", name, c_name);
  gen_func_code(stmt_list);
  pop_locals();

  sbuf_printf(&sb_contents, "}\n");
}

static void compile_global_var(Node* n)
{
  static int counter = 0;
  counter++;

  Node* id = node_get_child(n, 0);
  Node* value = node_get_child(n, 1);
  set_local(mem_asprintf("%s%s", module_prefix, id->text),
            mem_asprintf("global_%d", counter));
  sbuf_printf(&sb_header, "static Value global_%d;\n", counter);
  sbuf_printf(&sb_init2, "  global_%d = %s;\n", counter, eval_expr(value));
}

static void gen_constructor(Node* constructor)
{
  context2 = CONTEXT_CONSTRUCTOR;

  // Get basic stuff.
  static int counter = 0;
  counter++;
  const char* r_constructor_name = mem_asprintf("%s%s.%s",
    module_prefix, context_class_name, node_get_string(constructor, "name"));
  const char* c_constructor_name = mem_asprintf("__cons%d_%s", counter,
                                        util_make_c_name(r_constructor_name));

  Node* param_list = node_get_child(constructor, 0);
  Node* stmt_list = node_get_child(constructor, 1);
  int num_params = param_list->children.size;

  push_locals();

  const char* c_value = mem_asprintf("v_constructor%d", counter);
  sbuf_printf(&sb_init1, "  Value %s = func%d_to_val(%s);\n",
              c_value, num_params, c_constructor_name);
  if (check_vararg(param_list))
    sbuf_printf(&sb_init1, "  func_set_vararg(%s);\n", c_value);
  sbuf_printf(&sb_init1, "  ssym_set(\"%s\", %s);\n",
              r_constructor_name, c_value);

  sbuf_printf(&sb_contents, "static Value %s(%s){\n",
              c_constructor_name, gen_params(param_list));
  set_local("self", "__self");
  sbuf_printf(&sb_contents, "  %s* _c_data;\n", context_class_typedef);
  sbuf_printf(&sb_contents, "  Value __self = obj_new(%s, (void**) &_c_data);\n",
              context_class_c_name);
  dowhile_semaphore = 0;
  compile_stmtlist(stmt_list);
  sbuf_printf(&sb_contents, "  return __self;\n");
  pop_locals();
  sbuf_printf(&sb_contents, "}\n");
}

static void gen_method(const char* method_name, Node* param_list, Node* stmt_list)
{
  context2 = CONTEXT_METHOD;

  static int counter = 0;
  counter++;
  const char* r_method_name = mem_asprintf("%s%s.%s",
    module_prefix, context_class_name, method_name);
  const char* c_method_name = mem_asprintf("__met%d_%s", counter,
                                util_make_c_name(r_method_name));

  node_prepend_child(param_list, node_new_token(ID, "self", NULL, 0));
  int num_params = param_list->children.size;

  push_locals();
  context2_method_value_name = mem_asprintf("v_method%d", counter);
  sbuf_printf(&sb_init1, "  Value %s = func%d_to_val(%s);\n",
              context2_method_value_name, num_params, c_method_name);
  if (check_vararg(param_list))
    sbuf_printf(&sb_init1, "  func_set_vararg(%s);\n", context2_method_value_name);
  sbuf_printf(&sb_init1, "  ssym_set(\"%s\", %s);\n",
              r_method_name, context2_method_value_name);
  sbuf_printf(&sb_init1, "  klass_new_method(%s, dsym_get(\"%s\"), "
                           "%s);\n", context_class_c_name,
                           method_name,
                           context2_method_value_name);

  sbuf_printf(&sb_contents, "static Value %s(%s){\n",
              c_method_name, gen_params(param_list));
  if (context_class_type == CLASS_CDATA_OBJECT
      or context_class_type == CLASS_FIELD_OBJECT){
    sbuf_printf(&sb_contents, "  %s* _c_data;\n", context_class_typedef);
    sbuf_printf(&sb_contents, "  _c_data = (%s*) obj_c_data(__self);\n",
                context_class_typedef);
  }
  gen_func_code(stmt_list);
  pop_locals();

  sbuf_printf(&sb_contents, "}\n");
}

static void gen_class(Node* klass)
{
  push_locals();
  static int counter = 0;
  counter++;
  context = CONTEXT_CLASS;
  context_class_name = node_get_string(klass, "name");
  context_class_c_name = mem_asprintf("klass%d", counter);
  context_class_dict = dict_new(sizeof(char*), sizeof(char*),
                                dict_hash_string, dict_equal_string);
  sbuf_printf(&sb_header, "static Klass* %s;\n", context_class_c_name);
  Node* ast = node_get_child(klass, 0);

  // Figure out the type of the object
  context_class_type = CLASS_VIRTUAL_OBJECT;
  for (int i = 0; i < ast->children.size; i++){
    Node* n = node_get_child(ast, i);
    if (n->type == C_CODE){
      if (context_class_type == CLASS_FIELD_OBJECT){
        raise_error(mem_asprintf("class %s with both cdata and fields",
                                 context_class_name), klass);
      }
      context_class_type = CLASS_CDATA_OBJECT;
    }
    if (n->type == TL_VAR){
      if (context_class_type == CLASS_CDATA_OBJECT){
        raise_error(mem_asprintf("class %s with both cdata and fields",
                                 context_class_name), klass);
      }
      context_class_type = CLASS_FIELD_OBJECT;
    }
  }

  // Generate class and any of the cdata/fields
  switch(context_class_type){
    case CLASS_CDATA_OBJECT:
      context_class_typedef = mem_asprintf("KlassCData%d", counter);
      sbuf_printf(&sb_header, "typedef struct {\n");
      for (int i = 0; i < ast->children.size; i++){
        Node* n = node_get_child(ast, i);
        if (n->type == C_CODE){
          sbuf_printf(&sb_header, "%s", util_trim_ends(n->text));
        }
      }
      sbuf_printf(&sb_header, "} %s;\n", context_class_typedef);
      // TODO: Class parents
      sbuf_printf(&sb_init1, "  %s = klass_new(dsym_get(\"%s\"), "
                             "dsym_get(\"%s\"), KLASS_CDATA_OBJECT, sizeof(%s));\n",
                  context_class_c_name, context_class_name, "Object",
                  context_class_typedef);
      break;
    case CLASS_FIELD_OBJECT:
      // _c_data is of the type Value* for field objects
      context_class_typedef = "Value";
      sbuf_printf(&sb_init1, "  %s = klass_new(dsym_get(\"%s\"), "
                             "dsym_get(\"%s\"), KLASS_FIELD_OBJECT, 0);\n",
                  context_class_c_name, context_class_name, "Object");

      for (int i = 0; i < ast->children.size; i++){
        Node* n = node_get_child(ast, i);
        if (n->type == TL_VAR){
          const char* var_name = node_get_string(n, "name");
          const char* annotation = node_get_string(n, "annotation");
          const char* var_type = "";
          if (strcmp(annotation, "readable") == 0){
            var_type = "FIELD_READABLE";
          } else if (strcmp(annotation, "writable") == 0){
            var_type = "FIELD_READABLE | FIELD_WRITABLE";
          } else if (strcmp(annotation, "private") == 0){
            var_type = "0";
          } else {
            raise_error(mem_asprintf("invalid annotation '%s'", annotation), n);
          }
          sbuf_printf(&sb_init1, "  klass_new_field(%s, dsym_get(\"%s\"), "
                                   "%s);\n", context_class_c_name, var_name,
                                   var_type);
        }
      }
      break;
    case CLASS_VIRTUAL_OBJECT:
      context_class_typedef = NULL;
      sbuf_printf(&sb_init1, "  %s = klass_new(dsym_get(\"%s\"), "
                             "dsym_get(\"%s\"), KLASS_VIRTUAL_OBJECT, 0);\n",
                  context_class_c_name, context_class_name, "Object");
  }

  // Generate all the methods and constructors
  for (int i = 0; i < ast->children.size; i++){
    Node* n = node_get_child(ast, i);
    switch(n->type){
      case ANNOT_FUNCTION:
        {
          const char* annotation = node_get_string(n, "annotation");
          if (strcmp(annotation, "constructor")==0){
            gen_constructor(n);
          } else if (strcmp(annotation, "virtual_set")==0){
            const char* var_name = node_get_string(n, "name");
            gen_method(mem_asprintf("set_%s", var_name),
                        node_get_child(n, 0),
                        node_get_child(n, 1));
            sbuf_printf(&sb_init1,
                        "  klass_new_virtual_writer(%s, dsym_get(\"%s\"), %s);\n",
                        context_class_c_name,
                        var_name,
                        context2_method_value_name);
          } else if (strcmp(annotation, "virtual_get")==0){
            const char* var_name = node_get_string(n, "name");
            gen_method(mem_asprintf("get_%s", var_name),
                        node_get_child(n, 0),
                        node_get_child(n, 1));
            sbuf_printf(&sb_init1,
                        "  klass_new_virtual_reader(%s, dsym_get(\"%s\"), %s);\n",
                        context_class_c_name,
                        var_name,
                        context2_method_value_name);
          } else {
            raise_error(mem_asprintf("function annotated with '%s' "
                                     "not allowed inside a class",
                                     annotation),
                        n);
          }
        }
        break;
      case FUNCTION:
        gen_method(node_get_string(n, "name"),
                    node_get_child(n, 0),
                    node_get_child(n, 1));
        break;
      case C_CODE:
      case TL_VAR:
        /* Ignore */
        break;
      default:
        raise_error("top level not allowed inside a class", n);
    }
  }
  context = CONTEXT_NONE;
  pop_locals();
}

// Iterate through the abstract syntax tree, and add all the global variables.
static void gen_globals(Node* ast)
{
  for (int i = 0; i < ast->children.size; i++){
    Node* n = node_get_child(ast, i);
    if (n->type == GLOBAL_VAR){
      compile_global_var(n);
    }
    if (n->type == MODULE){
      const char* name = node_get_string(n, "name");
      module_push(name);
      Node* toplevels = node_get_child(n, 0);
      gen_globals(toplevels);
      module_pop(name);
    }
  }
}

static void gen_toplevels(Node* ast)
{
  for (int i = 0; i < ast->children.size; i++){
    Node* n = node_get_child(ast, i);
    switch(n->type){
      case FUNCTION:
        compile_function(n);
        break;
      case MODULE:
        {
          const char* name = node_get_string(n, "name");
          module_push(name);
          Node* toplevels = node_get_child(n, 0);
          gen_toplevels(toplevels);
          module_pop(name);
        }
        break;
      case C_CODE:
        {
          sbuf_printf(&sb_header, "%s\n", util_trim_ends(n->text));
        }
        break;
      case CONST:
        {
          sbuf_printf(&sb_init1, "  ssym_set(\"%s\", %s);\n",
                      mem_asprintf("%s%s",
                                   module_prefix,
                                   node_get_child(n, 0)->text),
                      eval_expr(node_get_child(n, 1)));
        }
      case GLOBAL_VAR:
        // Ignore.
        break;
      case CLASS:
        {
          gen_class(n);
        }
        break;
      case ANNOT_FUNCTION:
        raise_error("annotated functions not allowed outside of a class", n);
      default:
        assert_never();
    }
  }
}

#include <errno.h>
int generate(Node* ast, const char* module_name, const char* i_source_filename,
             const char* output_filename)
{
  dump_init();
  locals_init();
  tables_init();
  module_init();
  context = CONTEXT_NONE;

  // Set up error handling.
  source_filename = i_source_filename;
  if (setjmp(jb)){
    return 1;
  }

  // First item on the locals stack refers to the global variables.
  push_locals();
  // Globals have to be done separately of the rest, because they don't depend
  // on location in the file.
  gen_globals(ast);
  gen_toplevels(ast);
  pop_locals();

  // Output handling.
  FILE* f = fopen(output_filename, "w");
  if (f == NULL){
    fprintf(stderr, "cannot open '%s' for writing: %s\n",
            output_filename, strerror(errno));
    return 1;
  }
  dump_output(f, module_name);
  fclose(f);
  return 0;
}
